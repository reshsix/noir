/*
 *  This file is part of MaidCard Noir
 *
 *  MaidCard Noir is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU General Public License
 *  as published by the Free Software Foundation; either version 3
 *  of the License, or (at your option) any later version.
 *
 *  MaidCard Noir is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 *  See the GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with MaidCard Noir; if not, see <https://www.gnu.org/licenses/>.
*/

#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>

#define STB_IMAGE_IMPLEMENTATION
#include <stb_image.h>
#define STB_IMAGE_WRITE_IMPLEMENTATION
#include <stb_image_write.h>

typedef uint8_t  u8;
typedef uint16_t u16;

static u8 font[] = {
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe7, 0xdb, 0xb7, 0xc3,
  0xb9, 0xe3, 0xe7, 0xef, 0xf3, 0xf7, 0xff, 0xff, 0xff, 0xff, 0xbf, 0xc3,
  0xe7, 0xdb, 0xdb, 0xbd, 0xd2, 0xdb, 0xe7, 0xe7, 0xe7, 0xc3, 0xff, 0xff,
  0xff, 0xff, 0xdf, 0x99, 0xe7, 0xdb, 0xdb, 0xfd, 0xd6, 0xcb, 0xe7, 0xf7,
  0xef, 0xe7, 0xf7, 0xff, 0xff, 0xff, 0xcf, 0xbd, 0xe7, 0xdb, 0x81, 0xf1,
  0xe2, 0xe3, 0xe7, 0xf3, 0xef, 0xe3, 0xf7, 0xff, 0xff, 0xff, 0xef, 0xbd,
  0xe7, 0xff, 0xdb, 0xc7, 0xf1, 0xb1, 0xff, 0xf3, 0xcf, 0xff, 0x81, 0xff,
  0xff, 0xff, 0xe7, 0xa5, 0xe7, 0xff, 0xdb, 0xbf, 0x97, 0x94, 0xff, 0xf3,
  0xcf, 0xff, 0xf7, 0xff, 0xc3, 0xff, 0xf7, 0xb5, 0xff, 0xff, 0x80, 0xbf,
  0x6b, 0xce, 0xff, 0xf3, 0xcf, 0xff, 0xf7, 0xff, 0xff, 0xff, 0xfb, 0xbd,
  0xff, 0xff, 0xed, 0xbd, 0x69, 0xcc, 0xff, 0xf3, 0xcf, 0xff, 0xf7, 0xf3,
  0xff, 0xe7, 0xf9, 0xd9, 0xe7, 0xff, 0xed, 0xc3, 0x9d, 0x01, 0xff, 0xf3,
  0xef, 0xff, 0xff, 0xf3, 0xff, 0xe7, 0xfd, 0xc3, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xf7, 0xef, 0xff, 0xff, 0xfb, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe7, 0xe7, 0xff, 0xff, 0xfb,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xef,
  0xf3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xef, 0xc3, 0xc3, 0xcf, 0x81, 0xc3, 0x81, 0xc3, 0xc3, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xc3, 0xc3, 0xe3, 0x99, 0x99, 0xcf, 0xfd, 0x9b, 0xdf, 0x99,
  0xd9, 0xff, 0xff, 0xff, 0xff, 0xff, 0x99, 0xb9, 0xe9, 0x9d, 0x9d, 0xd7,
  0xfd, 0xfd, 0xdf, 0x9d, 0x9d, 0xe7, 0xe7, 0x8f, 0xff, 0xf1, 0x9d, 0x85,
  0xef, 0x9f, 0xdf, 0xdb, 0xc1, 0xc1, 0xef, 0xd9, 0x9d, 0xe7, 0xe7, 0xe3,
  0x81, 0xc7, 0x9f, 0x58, 0xef, 0xcf, 0xc7, 0xdb, 0x99, 0x99, 0xef, 0xc3,
  0x99, 0xff, 0xff, 0xfd, 0xff, 0x9f, 0xcf, 0x5a, 0xef, 0xe7, 0x9f, 0xdd,
  0xbf, 0xbd, 0xe7, 0x99, 0x83, 0xff, 0xff, 0xf1, 0xff, 0x8f, 0xe7, 0x5a,
  0xef, 0xf3, 0xbd, 0x81, 0xbf, 0xbd, 0xf7, 0xbd, 0x9f, 0xff, 0xff, 0xc7,
  0x81, 0xe3, 0xf7, 0xaa, 0xef, 0xf9, 0x99, 0xdf, 0x99, 0x9b, 0xf7, 0x99,
  0xd9, 0xe7, 0xe7, 0xbf, 0xff, 0xfd, 0xff, 0x92, 0x81, 0x81, 0xc3, 0xdf,
  0xc3, 0xc3, 0xf7, 0xc3, 0xe3, 0xe7, 0xf7, 0xff, 0xff, 0xff, 0xf7, 0xfd,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf7, 0xff,
  0xff, 0xff, 0xff, 0x9d, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xf3, 0xff, 0xff, 0xff, 0xff, 0xe3, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xe7, 0xc1, 0xc3, 0xe1, 0x81, 0x81, 0xc3, 0xbd,
  0x81, 0xc7, 0x9d, 0xf9, 0x99, 0xb9, 0xc3, 0xc1, 0xe7, 0x9d, 0x99, 0xdd,
  0xfd, 0xfd, 0x99, 0xbd, 0xe7, 0xdf, 0xdd, 0xf9, 0x99, 0xb9, 0x99, 0x9d,
  0xc3, 0xbd, 0xfd, 0xbd, 0xfd, 0xfd, 0xfd, 0xbd, 0xe7, 0xdf, 0xed, 0xf9,
  0x99, 0xb1, 0xbd, 0xbd, 0xcb, 0xdd, 0xfd, 0xbd, 0xfd, 0xfd, 0xfd, 0xbd,
  0xe7, 0xdf, 0xf5, 0xf9, 0xa1, 0xb5, 0xbd, 0xbd, 0xdb, 0xc1, 0xfd, 0xbd,
  0xc1, 0xfd, 0x8d, 0x81, 0xe7, 0xdf, 0xe1, 0xf9, 0xa5, 0xb5, 0xbd, 0x9d,
  0x99, 0xbd, 0xfd, 0xbd, 0xfd, 0x81, 0xbd, 0x9d, 0xe7, 0xdf, 0xe9, 0xf9,
  0xa5, 0xad, 0xbd, 0xc1, 0x81, 0xbd, 0xbd, 0xbd, 0xfd, 0xfd, 0xbd, 0xbd,
  0xe7, 0xdf, 0xdd, 0xf9, 0xbd, 0x8d, 0xbd, 0xfd, 0xbc, 0xbd, 0x99, 0xdd,
  0xfd, 0xfd, 0xb9, 0xbd, 0xe7, 0xd9, 0x9d, 0xf9, 0xbd, 0x9d, 0xd9, 0xfd,
  0x3c, 0xc1, 0xc3, 0xe1, 0x81, 0xfd, 0xc3, 0xbd, 0x81, 0xe3, 0xbd, 0x81,
  0xbd, 0x9d, 0xc3, 0xfd, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf7, 0xc3, 0xc1, 0xc3, 0x80,
  0xbd, 0x3c, 0x3e, 0xbd, 0xbc, 0x81, 0xc7, 0xfd, 0xe3, 0xe7, 0xff, 0xef,
  0xd9, 0x9d, 0x99, 0xe7, 0xbd, 0xbc, 0x3e, 0xd9, 0x99, 0x9f, 0xf7, 0xf9,
  0xef, 0xe7, 0xff, 0xff, 0xbd, 0xbd, 0xfd, 0xe7, 0xbd, 0xbd, 0x3c, 0xcb,
  0xdb, 0xdf, 0xf7, 0xfb, 0xef, 0xcb, 0xff, 0xff, 0xbd, 0x9d, 0xf9, 0xe7,
  0xbd, 0x99, 0xa4, 0xe7, 0xc3, 0xef, 0xf7, 0xf7, 0xef, 0xdb, 0xff, 0xff,
  0xbd, 0xc1, 0xc3, 0xe7, 0xbd, 0xdb, 0xa5, 0xe7, 0xe7, 0xf7, 0xf7, 0xe7,
  0xef, 0xd9, 0xff, 0xff, 0xbd, 0xed, 0x9f, 0xe7, 0xbd, 0xdb, 0xa5, 0xe3,
  0xe7, 0xf3, 0xf7, 0xef, 0xef, 0xbd, 0xff, 0xff, 0xbd, 0xdd, 0xbf, 0xe7,
  0xbd, 0xc3, 0x89, 0xdb, 0xe7, 0xfb, 0xf7, 0xcf, 0xef, 0xff, 0xff, 0xff,
  0x99, 0x9d, 0x9d, 0xe7, 0x99, 0xe7, 0x99, 0x99, 0xe7, 0xfd, 0xf7, 0xdf,
  0xef, 0xff, 0xff, 0xff, 0xc3, 0xbd, 0xc3, 0xe7, 0xc3, 0xe7, 0x99, 0xbc,
  0xe7, 0x80, 0xf7, 0xbf, 0xef, 0xff, 0xff, 0xff, 0xe7, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf7, 0xff, 0xef, 0xff, 0xff, 0xff,
  0xef, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf7, 0xff,
  0xef, 0xff, 0x00, 0xff, 0x9f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xc7, 0xff, 0xe3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xfd, 0xff, 0x9f, 0xff, 0x87, 0xff, 0xfd, 0xe7, 0xef, 0xf9, 0xe3,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xfd, 0xff, 0x9f, 0xff, 0xf7, 0xff, 0xfd,
  0xff, 0xff, 0xf9, 0xe7, 0xff, 0xff, 0xff, 0xff, 0xc3, 0xc1, 0xc3, 0x83,
  0xc3, 0x81, 0x83, 0xc1, 0xe3, 0xe3, 0x99, 0xe7, 0x91, 0xc1, 0xc3, 0xc1,
  0xd9, 0x99, 0x99, 0x99, 0x99, 0xf3, 0x99, 0x99, 0xef, 0xef, 0xc9, 0xe7,
  0xa5, 0x99, 0x99, 0x99, 0xdf, 0xb9, 0xfd, 0x9d, 0xbd, 0xf3, 0x9d, 0x9d,
  0xef, 0xef, 0xe1, 0xe7, 0xa5, 0x9d, 0xbd, 0xb9, 0xc3, 0xbd, 0xfd, 0x9d,
  0x81, 0xf3, 0x9d, 0x9d, 0xef, 0xef, 0xe1, 0xe7, 0xa5, 0x9d, 0xbd, 0xbd,
  0xdd, 0xbd, 0xfd, 0x9d, 0xfd, 0xf3, 0x9d, 0x9d, 0xef, 0xef, 0xe9, 0xe7,
  0xa5, 0x9d, 0xbd, 0xb9, 0xdd, 0x99, 0x99, 0x99, 0xd9, 0xf3, 0x99, 0x9d,
  0xef, 0xef, 0xd9, 0xe7, 0xa5, 0x9d, 0x99, 0x99, 0x81, 0xc1, 0xc3, 0x83,
  0xc3, 0xf3, 0x83, 0x9d, 0x81, 0xef, 0x99, 0x8f, 0xa5, 0x9d, 0xc3, 0xc1,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x9f, 0xff, 0xff, 0xef, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xfd, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xd9, 0xff,
  0xff, 0xef, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfd, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xc3, 0xff, 0xff, 0xf1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfd,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf3, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0x8f, 0xe7, 0xf1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf3,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf7, 0xe7, 0xe7, 0xff, 0xff, 0xff,
  0x83, 0x8b, 0xc3, 0xc1, 0x9d, 0xbd, 0x3e, 0x9d, 0xbd, 0x81, 0xf7, 0xe7,
  0xe7, 0xff, 0xff, 0xff, 0x99, 0xf3, 0xd9, 0xf3, 0x9d, 0x9d, 0x3c, 0xdb,
  0xbd, 0xdf, 0xf7, 0xe7, 0xe7, 0xff, 0xff, 0xff, 0x9d, 0xfb, 0xf9, 0xf3,
  0x9d, 0xd9, 0xa4, 0xe3, 0xd9, 0xef, 0xf7, 0xe7, 0xef, 0xf1, 0xff, 0xff,
  0x9d, 0xfb, 0xc3, 0xf3, 0x9d, 0xdb, 0xa5, 0xe7, 0xdb, 0xf7, 0xf9, 0xe7,
  0xcf, 0x8f, 0xff, 0xff, 0x9d, 0xfb, 0x9f, 0xf3, 0x9d, 0xcb, 0x89, 0xe3,
  0xcb, 0xf3, 0xf7, 0xe7, 0xef, 0xff, 0xff, 0xff, 0x99, 0xfb, 0x9d, 0xf3,
  0x99, 0xe7, 0x99, 0xdb, 0xe7, 0xf9, 0xf7, 0xe7, 0xe7, 0xff, 0xff, 0xff,
  0x83, 0xfb, 0xc3, 0xc7, 0x83, 0xe7, 0x99, 0x9d, 0xe7, 0x81, 0xf7, 0xe7,
  0xe7, 0xff, 0xff, 0xff, 0x9f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xf7, 0xff, 0xf7, 0xe7, 0xe7, 0xff, 0xff, 0xff, 0x9f, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xf7, 0xff, 0xe7, 0xe7, 0xe7, 0xff, 0xff, 0xff,
  0x9f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf9, 0xff, 0x8f, 0xe7,
  0xf1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
};
const size_t font_s = 1536;

static u8 font_d[4096] = {0};

static inline bool
font_bit(char c, u8 x, u8 y)
{
    return font_d[(c * 16) + y] & (1 << x);
}

static inline u8
font_byte(char c, u8 y)
{
    return font_d[(c * 16) + y];
}

static void
line_write(const char *in, u16 ix, u16 iy, u8 *data, u16 w, u16 h)
{
    u16 x = (ix * 8)  + ((w % 8)  / 2);
    u16 y = (iy * 16) + ((h % 16) / 2);

    size_t length = (in) ? strlen(in) : 0;
    if (length && (x + (length * 8)) <= w && ((y + 16) <= h))
    {
        for (size_t i = 0; i < length; i++)
        {
            for (u16 j = 0; j < 8; j++)
            {
                for (u16 k = 0; k < 16; k++)
                {
                    if (font_bit(in[i], j, k))
                    {
                        u16 x2 = x + (i * 8) + j;
                        u16 y2 = y + k;

                        size_t idx = (y2 * w) + x2;
                        for (u8 l = 0; l < 4; l++)
                            data[(idx * 4) + l] = 255;
                    }
                }
            }
        }
    }
}

static size_t
line_read(char *out, u16 ix, u16 iy, u8 *data, u16 w, u16 h)
{
    size_t ret = 0;

    u16 x = (ix * 8)  + ((w % 8)  / 2);
    u16 y = (iy * 16) + ((h % 16) / 2);

    for (u16 i = 0; i < (w - x) / 8; i++)
    {
        u8 count[8 * 16] = {0};
        u8   max[8 * 16] = {0};

        /* Counts white pixels */
        for (u16 j = 0; j < 8; j++)
        {
            for (u16 k = 0; k < 16; k++)
            {
                u16 x2 = x + (i * 8) + j;
                u16 y2 = y + k;

                size_t idx = (y2 * w) + x2;

                bool bit = true;
                for (u8 l = 0; l < 4; l++)
                    bit &= (data[(idx * 4) + l] == 255);

                count[(k * 8) + j] += bit;
                max  [(k * 8) + j] += 1;
            }
        }

        /* Approximates the character */
        u8 matrix[16] = {0};
        for (u8 k = 0; k < 16; k++)
        {
            for (u8 j = 0; j < 8; j++)
            {
                if (count[(k * 8 + j)] > max[(k * 8 + j)] / 2)
                    matrix[k] |= (1 << j);
                else
                    matrix[k] &= ~(1 << j);
            }
        }

        /* Finds the best matching character */
        char c = ' ';
        u8 score = 0;
        for (u8 j = 32; j < 127; j++)
        {
            u8 current = 0;
            for (u8 k = 0; k < 16; k++)
            {
                u8 cmp = matrix[k] ^ font_byte(j, k);
                for (int l = 0; l < 8; l++)
                {
                    if (!(cmp & (1 << l)))
                        current++;
                }
            }

            if (current > score)
            {
                score = current;
                c = j;
            }
        }

        /* If there's less than 75% certainty, breaks */
        if (score < 96)
            break;

        out[i] = c;
        ret++;
    }

    return ret;
}

static bool
writer(u8 *data, u16 w, u16 h)
{
    bool ret = true;

    /* Darkens the image */
    for (int i = 0; i < w * h * 4; i++)
    {
        if (i % 4 != 3)
            data[i] /= 2;
    }

    /* Calculates max lengths */
    u16 line_c = 0;
    u16 line_s = (w / 8);
    char line[line_s + 1];

    u16 line_n = 0;
    u16 lines = (h / 16);
    if (line_s && lines)
    {
        /* Writer loop */
        while (line_n < lines)
        {
            int c = fgetc(stdin);

            if (c >= 32 && c <= 126)
                line[line_c++] = c;
            else if (c != '\n' && c != EOF)
            {
                fprintf(stderr, "Invalid character (0x%02u)\n", c);
                ret = false;
                break;
            }

            if (c == EOF || c == '\n' || line_c == line_s)
            {
                line[line_c] = '\0';
                line_c = 0;

                line_write(line, 0, line_n++, data, w, h);
                if (c == EOF)
                    break;
            }
        }

        if (fgetc(stdin) != EOF)
        {
            fprintf(stderr, "Input is too long (>%d lines of %d chars)\n",
                    lines, line_s);
            ret = false;
        }
    }
    else
    {
        fprintf(stderr, "Image is too small (%dx%d)\n", w, h);
        ret = false;
    }

    return ret;
}

static bool
reader(u8 *data, u16 w, u16 h)
{
    bool ret = true;

    /* Calculates max lengths */
    u16 line_s = (w / 8);
    char line[line_s + 1];

    u16 line_n = 0;
    u16 lines = (h / 16);
    if (line_s && lines)
    {
        u16 empty = 0;

        /* Reader loop */
        while (line_n < lines)
        {
            size_t read = line_read(line, 0, line_n, data, w, h);
            if (read == line_s)
            {
                /* Trim whitespaces */
                line[line_s] = ' ';
                for (int i = line_s; i >= 0; i--)
                {
                    if (line[i] != ' ')
                        break;

                    line[i] = '\0';
                }

                /* Trim trailing empty lines */
                if (line[0] != '\0')
                {
                    /* Print empty lines */
                    for (int i = 0; i < empty; i++)
                        fprintf(stdout, "\n");
                    empty = 0;

                    /* Print text line */
                    fprintf(stdout, "%s\n", line);
                }
                else
                    empty++;

                line_n++;
            }
            else
            {
                fprintf(stderr, "Failed to read character %ld from line %d\n",
                        read, line_n);
                ret = false;
                break;
            }
        }
    }
    else
    {
        fprintf(stderr, "Image is too small (%dx%d)\n", w, h);
        ret = false;
    }

    return ret;
}

static u8 *
init(const char *file, int *w, int *h)
{
    u8 *ret = NULL;

    size_t outl = strlen(file);
    if (strcmp(&(file[outl - 4]), ".png") ||
        strcmp(&(file[outl - 4]), ".tga") ||
        strcmp(&(file[outl - 4]), ".bmp"))
    {
        int c = 0;
        ret = stbi_load(file, w, h, &c, 4);
        if (*w > 65535 || *h > 65535)
        {
            free(ret);
            ret = NULL;
        }

        if (ret)
        {
            /* Loads font transposed and inverted */
            for (int i = 33; i < 127; i++)
            {
                for (int j = 0; j < 16; j++)
                {
                    u8 x = (i - 33) % 16;
                    u8 y = (i - 33) / 16;

                    u16 idx_a = (i * 16) + j;
                    u16 idx_b = (y * 256) + x + (j * 16);
                    font_d[idx_a] = ~(font[idx_b]);
                }
            }
        }
    }
    else
    {
        fprintf(stderr, "Unsupported extension\n");
        ret = false;
    }

    return ret;
}

static bool
usage(void)
{
    fprintf(stderr, "MaidCard Noir: A Virtual Card for Maids\n\n");
    fprintf(stderr, "usage: noir write [input] [output] < text\n");
    fprintf(stderr, "       noir read  [input]\n");

    return false;
}

extern int
main(int argc, char *argv[])
{
    bool ret = true;

    if (argc == 4 && strcmp(argv[1], "write") == 0)
    {
        int ext = 0;
        size_t outl = strlen(argv[3]);
        if (strcmp(&(argv[3][outl - 4]), ".png") == 0)
            ext = 1;
        else if (strcmp(&(argv[3][outl - 4]), ".tga") == 0)
            ext = 2;
        else if (strcmp(&(argv[3][outl - 4]), ".bmp") == 0)
            ext = 3;
        else
        {
            fprintf(stderr, "Unsupported extension\n");
            ret = false;
        }

        if (ret)
        {
            int w, h;
            u8 *data = init(argv[2], &w, &h);
            if (data)
            {
                writer(data, w, h);
                switch (ext)
                {
                    case 1:
                        stbi_write_png(argv[3], w, h, 4, data, w * 4);
                        break;
                    case 2:
                        stbi_write_tga(argv[3], w, h, 4, data);
                        break;
                    case 3:
                        stbi_write_bmp(argv[3], w, h, 4, data);
                        break;
                    default:
                        break;
                }
            }
            else
            {
                fprintf(stderr, "Failed to load image\n");
                ret = false;
            }
            free(data);
        }
    }
    else if (argc == 3 && strcmp(argv[1], "read") == 0)
    {
        int w, h;
        u8 *data = init(argv[2], &w, &h);
        if (data)
            reader(data, w, h);
        else
        {
            fprintf(stderr, "Failed to load image\n");
            ret = false;
        }
        free(data);
    }
    else
        ret = usage();

    return (ret) ? EXIT_SUCCESS : EXIT_FAILURE;
}
